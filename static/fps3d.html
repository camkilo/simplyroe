<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realm of Echoes - 3D FPS</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #000;
        }
        
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            color: white;
            font-size: 16px;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }
        
        #crosshair::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            transform: translateY(-50%);
        }
        
        #crosshair::after {
            left: 50%;
            top: 0;
            width: 2px;
            height: 100%;
            transform: translateX(-50%);
        }
        
        #stats {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00ffff;
        }
        
        #inventory {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00ffff;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .inventory-slot {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #00ffff;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            text-align: center;
            position: relative;
        }
        
        .inventory-slot.active {
            border-color: #ffff00;
            box-shadow: 0 0 15px #ffff00;
        }
        
        .inventory-slot .count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00ffff;
            font-size: 14px;
        }
        
        /* Mobile Joystick Controls */
        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        @media (max-width: 768px), (pointer: coarse) {
            .mobile-controls {
                display: block;
            }
            
            #controls {
                display: none;
            }
        }
        
        .joystick-zone {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 150px;
            height: 150px;
            pointer-events: auto;
        }
        
        .joystick-base {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.2), rgba(0, 255, 255, 0.05));
            border: 3px solid rgba(0, 255, 255, 0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .joystick-stick {
            position: absolute;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.8), rgba(0, 255, 255, 0.4));
            border: 2px solid #00ffff;
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
            transform: translate(-50%, -50%);
            left: 50%;
            top: 50%;
            transition: all 0.1s ease-out;
        }
        
        .action-buttons {
            position: absolute;
            bottom: 60px;
            right: 40px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
        }
        
        .action-button {
            width: 70px;
            height: 70px;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.3), rgba(0, 255, 255, 0.1));
            border: 3px solid rgba(0, 255, 255, 0.6);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #00ffff;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
        }
        
        .action-button:active {
            background: radial-gradient(circle, rgba(0, 255, 255, 0.6), rgba(0, 255, 255, 0.3));
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
            transform: scale(0.9);
        }
        
        .mobile-info {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 8px;
            border: 2px solid #00ffff;
            color: white;
            font-size: 12px;
            text-align: center;
            pointer-events: auto;
        }
        
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 1000;
        }
        
        #loading.hidden {
            display: none;
        }
        
        .spinner {
            border: 4px solid rgba(0, 255, 255, 0.1);
            border-top: 4px solid #00ffff;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 8px;
            border: 2px solid #00ffff;
            display: none;
            max-width: 400px;
            text-align: center;
        }
        
        #message.show {
            display: block;
        }
        
        button {
            pointer-events: auto;
            background: #00ffff;
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            margin-top: 10px;
        }
        
        button:hover {
            background: #00cccc;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="loading">
        <div class="spinner"></div>
        <div style="color: #00ffff; font-size: 24px;">Loading Realm of Echoes...</div>
        <div style="color: #888; margin-top: 10px;">Initializing 3D World</div>
    </div>
    
    <div id="hud">
        <div id="crosshair"></div>
        
        <div id="stats">
            <div><strong>REALM OF ECHOES - 3D FPS</strong></div>
            <div style="margin-top: 10px;">Health: <span id="health">100</span></div>
            <div>Location: <span id="location">Forest</span></div>
            <div>Biome: <span id="biome">plains</span></div>
            <div>Position: <span id="position">0, 0, 0</span></div>
            <div>XP: <span id="xp">0</span></div>
        </div>
        
        <div id="controls">
            <div><strong>CONTROLS</strong></div>
            <div style="margin-top: 10px;">WASD - Move</div>
            <div>Mouse - Look</div>
            <div>Left Click - Interact/Attack</div>
            <div>E - Gather Resources</div>
            <div>Q - Craft</div>
            <div>1-5 - Select Item</div>
            <div>Space - Jump</div>
            <div>Shift - Sprint</div>
            <div>ESC - Pause</div>
        </div>
        
        <div id="inventory">
            <div class="inventory-slot active" data-slot="0"><span>Empty</span></div>
            <div class="inventory-slot" data-slot="1"><span>Empty</span></div>
            <div class="inventory-slot" data-slot="2"><span>Empty</span></div>
            <div class="inventory-slot" data-slot="3"><span>Empty</span></div>
            <div class="inventory-slot" data-slot="4"><span>Empty</span></div>
        </div>
        
        <div id="message">
            <div id="messageText"></div>
            <button onclick="closeMessage()">OK</button>
        </div>
    </div>
    
    <!-- Mobile Controls -->
    <div class="mobile-controls">
        <div class="mobile-info">
            Touch joystick to move • Tap screen to interact/attack • Buttons: Jump & Gather
        </div>
        <div class="joystick-zone" id="joystickZone">
            <div class="joystick-base">
                <div class="joystick-stick" id="joystickStick"></div>
            </div>
        </div>
        <div class="action-buttons">
            <div class="action-button" id="jumpButton">↑</div>
            <div class="action-button" id="gatherButton">E</div>
        </div>
    </div>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        
        // Detect mobile for performance optimization
        const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Game State
        const gameState = {
            health: 100,
            xp: 0,
            inventory: [],
            activeSlot: 0,
            location: 'Forest',
            position: { x: 0, y: 1.6, z: 0 },
            enemies: [],
            resources: []
        };
        
        // Scene Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // Sky blue
        // Reduce fog distance on mobile for better performance
        const fogDistance = isMobileDevice ? 100 : 200;
        scene.fog = new THREE.Fog(0x87ceeb, 30, fogDistance);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 0);
        
        const canvas = document.getElementById('gameCanvas');
        
        const renderer = new THREE.WebGLRenderer({ 
            canvas, 
            antialias: !isMobileDevice, // Disable AA on mobile for performance
            powerPreference: 'high-performance'
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Limit pixel ratio on mobile for better performance
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobileDevice ? 1.5 : 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = isMobileDevice ? THREE.BasicShadowMap : THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        renderer.outputEncoding = THREE.sRGBEncoding;
        
        // Lighting - Enhanced for next-gen graphics with advanced shadows and colors
        const ambientLight = new THREE.AmbientLight(0xb8d4ff, 0.5);
        scene.add(ambientLight);
        
        // Primary directional light (sun)
        const dirLight = new THREE.DirectionalLight(0xfff5e6, 1.5);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        const shadowMapSize = isMobileDevice ? 2048 : 4096;
        dirLight.shadow.mapSize.width = shadowMapSize;
        dirLight.shadow.mapSize.height = shadowMapSize;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 500;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        dirLight.shadow.bias = -0.00005;
        dirLight.shadow.normalBias = 0.02;
        scene.add(dirLight);
        
        // Add hemisphere light for natural sky lighting (enhanced)
        const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0xc4915f, 0.7);
        hemiLight.position.set(0, 50, 0);
        scene.add(hemiLight);
        
        // Add point lights for dramatic effect (more realistic)
        const pointLight1 = new THREE.PointLight(0xffaa33, 1.2, 60);
        pointLight1.position.set(20, 8, 20);
        pointLight1.castShadow = true;
        pointLight1.shadow.mapSize.width = 1024;
        pointLight1.shadow.mapSize.height = 1024;
        scene.add(pointLight1);
        
        const pointLight2 = new THREE.PointLight(0x33aaff, 1.0, 50);
        pointLight2.position.set(-20, 6, -20);
        pointLight2.castShadow = true;
        pointLight2.shadow.mapSize.width = 1024;
        pointLight2.shadow.mapSize.height = 1024;
        scene.add(pointLight2);
        
        // Add spotlight for focused dramatic lighting
        const spotLight = new THREE.SpotLight(0xffffff, 1.5, 100, Math.PI / 6, 0.3, 1);
        spotLight.position.set(-30, 40, 30);
        spotLight.target.position.set(0, 0, 0);
        spotLight.castShadow = true;
        spotLight.shadow.mapSize.width = 2048;
        spotLight.shadow.mapSize.height = 2048;
        scene.add(spotLight);
        scene.add(spotLight.target);
        
        // Controls
        const controls = new PointerLockControls(camera, canvas);
        
        const moveState = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            jump: false,
            sprint: false,
            canJump: true
        };
        
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        // Biome colors and properties - Enhanced with better materials and PBR
        const biomes = {
            forest: { 
                color: 0x2d5016, 
                roughness: 0.95, 
                metalness: 0.0, 
                emissive: 0x0a1505,
                normalScale: 0.5
            },
            plains: { 
                color: 0x7cb342, 
                roughness: 0.9, 
                metalness: 0.0, 
                emissive: 0x1a2e0a,
                normalScale: 0.3
            },
            desert: { 
                color: 0xe6b073, 
                roughness: 0.8, 
                metalness: 0.05, 
                emissive: 0x3d2815,
                normalScale: 0.4
            },
            water: { 
                color: 0x1976d2, 
                roughness: 0.05, 
                metalness: 0.9, 
                emissive: 0x0a1f3d,
                normalScale: 0.8,
                transparent: true,
                opacity: 0.8
            },
            mountain: { 
                color: 0x5d5d5d, 
                roughness: 0.98, 
                metalness: 0.3, 
                emissive: 0x0a0a0a,
                normalScale: 1.0
            },
            ice: { 
                color: 0xb3e5fc, 
                roughness: 0.1, 
                metalness: 0.7, 
                emissive: 0x1a3d4d,
                normalScale: 0.6,
                transparent: true,
                opacity: 0.9
            },
            lava: { 
                color: 0xff3d00, 
                roughness: 0.2, 
                metalness: 0.4, 
                emissive: 0xff4500,
                normalScale: 0.5
            },
            swamp: { 
                color: 0x4a5d3e, 
                roughness: 0.9, 
                metalness: 0.0, 
                emissive: 0x121a0e,
                normalScale: 0.7
            }
        };
        
        // Particle system for effects
        const particleGeometry = new THREE.BufferGeometry();
        const particleCount = 100;
        const particles = [];
        
        function createParticleEffect(position, color) {
            const particleMaterial = new THREE.PointsMaterial({
                color: color,
                size: 0.25,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            const positions = [];
            const velocities = [];
            
            // Reduce particle count on mobile
            const particleCount = isMobileDevice ? 15 : 30;
            
            for (let i = 0; i < particleCount; i++) {
                positions.push(
                    position.x + (Math.random() - 0.5) * 0.5,
                    position.y + (Math.random() - 0.5) * 0.5,
                    position.z + (Math.random() - 0.5) * 0.5
                );
                velocities.push(
                    (Math.random() - 0.5) * 3,
                    Math.random() * 3 + 1,
                    (Math.random() - 0.5) * 3
                );
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const particleSystem = new THREE.Points(geometry, particleMaterial);
            particleSystem.userData = { velocities, lifetime: 1.5 };
            scene.add(particleSystem);
            particles.push(particleSystem);
        }
        
        function updateParticles(delta) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.userData.lifetime -= delta;
                
                if (particle.userData.lifetime <= 0) {
                    scene.remove(particle);
                    particles.splice(i, 1);
                } else {
                    const positions = particle.geometry.attributes.position.array;
                    const velocities = particle.userData.velocities;
                    
                    for (let j = 0; j < positions.length; j += 3) {
                        positions[j] += velocities[j] * delta;
                        positions[j + 1] += velocities[j + 1] * delta;
                        positions[j + 2] += velocities[j + 2] * delta;
                        velocities[j + 1] -= 9.8 * delta; // Gravity
                    }
                    
                    particle.geometry.attributes.position.needsUpdate = true;
                    particle.material.opacity = particle.userData.lifetime;
                }
            }
        }
        
        // Generate procedural world
        function generateWorld() {
            // Reduce world size on mobile for better performance
            const worldSize = isMobileDevice ? 60 : 100;
            const chunkSize = 10;
            
            // Ground plane with varied heights
            for (let x = -worldSize; x < worldSize; x += chunkSize) {
                for (let z = -worldSize; z < worldSize; z += chunkSize) {
                    // Determine biome based on position
                    const biomeType = getBiomeAt(x, z);
                    const biome = biomes[biomeType];
                    
                    // Create ground chunk with enhanced materials and PBR
                    const height = getHeightAt(x, z, biomeType);
                    const geometry = new THREE.BoxGeometry(chunkSize, height, chunkSize);
                    const material = new THREE.MeshStandardMaterial({
                        color: biome.color,
                        roughness: biome.roughness,
                        metalness: biome.metalness,
                        emissive: biome.emissive,
                        emissiveIntensity: biomeType === 'lava' ? 0.8 : 0.15,
                        transparent: biome.transparent || false,
                        opacity: biome.opacity || 1.0,
                        envMapIntensity: 1.5
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(x + chunkSize/2, height/2 - 1, z + chunkSize/2);
                    mesh.receiveShadow = true;
                    mesh.castShadow = true;
                    mesh.userData = { biome: biomeType };
                    scene.add(mesh);
                    
                    // Add resources/vegetation
                    if (Math.random() > 0.7 && biomeType !== 'water' && biomeType !== 'lava') {
                        addResource(x + Math.random() * chunkSize, height, z + Math.random() * chunkSize, biomeType);
                    }
                    
                    // Add enemies occasionally
                    if (Math.random() > 0.95 && biomeType !== 'water') {
                        addEnemy(x + Math.random() * chunkSize, height, z + Math.random() * chunkSize);
                    }
                }
            }
        }
        
        function getBiomeAt(x, z) {
            const biomeKeys = Object.keys(biomes);
            const seed = Math.sin(x * 0.01) * Math.cos(z * 0.01);
            const index = Math.floor((seed + 1) * 0.5 * biomeKeys.length) % biomeKeys.length;
            return biomeKeys[index];
        }
        
        function getHeightAt(x, z, biomeType) {
            if (biomeType === 'water') return 0.2;
            if (biomeType === 'mountain') return 2 + Math.abs(Math.sin(x * 0.1)) * 3;
            return 1 + Math.sin(x * 0.05) * 0.5 + Math.cos(z * 0.05) * 0.5;
        }
        
        function addResource(x, y, z, biomeType) {
            const resourceTypes = {
                forest: ['Wood', 'Herbs'],
                plains: ['Herbs', 'Stone'],
                desert: ['Stone', 'Copper'],
                mountain: ['Iron', 'Stone'],
                ice: ['Crystal', 'Ice'],
                swamp: ['Herbs', 'Mud']
            };
            
            const resources = resourceTypes[biomeType] || ['Stone'];
            const resourceType = resources[Math.floor(Math.random() * resources.length)];
            
            // Create improved 3D representation with enhanced glow effect
            const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const colorMap = {
                Wood: 0x8b4513,
                Herbs: 0x32cd32,
                Stone: 0x808080,
                Copper: 0xb87333,
                Iron: 0x708090,
                Crystal: 0x00ffff,
                Ice: 0xe0ffff,
                Mud: 0x654321
            };
            const material = new THREE.MeshStandardMaterial({
                color: colorMap[resourceType] || 0xffffff,
                roughness: 0.4,
                metalness: resourceType === 'Iron' || resourceType === 'Copper' ? 0.9 : 0.1,
                emissive: colorMap[resourceType] || 0xffffff,
                emissiveIntensity: resourceType === 'Crystal' ? 0.6 : 0.2,
                envMapIntensity: 2.0
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y + 0.5, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData = { type: 'resource', resourceType };
            scene.add(mesh);
            gameState.resources.push(mesh);
            
            // Add gentle bobbing animation
            mesh.userData.bobPhase = Math.random() * Math.PI * 2;
        }
        
        function addEnemy(x, y, z) {
            // Create improved enemy representation with glowing eyes
            const bodyGeometry = new THREE.CapsuleGeometry(0.5, 1, 4, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x880000,
                roughness: 0.7,
                emissive: 0x440000,
                emissiveIntensity: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            
            // Add glowing eyes
            const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 1.0
            });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.2, 0.3, 0.4);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.2, 0.3, 0.4);
            
            const enemy = new THREE.Group();
            enemy.add(body);
            enemy.add(leftEye);
            enemy.add(rightEye);
            
            enemy.position.set(x, y + 1, z);
            enemy.userData = { type: 'enemy', health: 30, name: 'Shadow Beast', maxHealth: 30 };
            scene.add(enemy);
            gameState.enemies.push(enemy);
        }
        
        // Input handling
        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': moveState.forward = true; break;
                case 'KeyS': moveState.backward = true; break;
                case 'KeyA': moveState.left = true; break;
                case 'KeyD': moveState.right = true; break;
                case 'Space': if (moveState.canJump) moveState.jump = true; break;
                case 'ShiftLeft': moveState.sprint = true; break;
                case 'KeyE': gatherResource(); break;
                case 'KeyQ': craft(); break;
                case 'Digit1': selectSlot(0); break;
                case 'Digit2': selectSlot(1); break;
                case 'Digit3': selectSlot(2); break;
                case 'Digit4': selectSlot(3); break;
                case 'Digit5': selectSlot(4); break;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': moveState.forward = false; break;
                case 'KeyS': moveState.backward = false; break;
                case 'KeyA': moveState.left = false; break;
                case 'KeyD': moveState.right = false; break;
                case 'ShiftLeft': moveState.sprint = false; break;
            }
        });
        
        canvas.addEventListener('click', () => {
            if (!controls.isLocked) {
                controls.lock();
            } else {
                attack();
            }
        });
        
        // Mobile Controls Implementation
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                         (window.matchMedia && window.matchMedia('(pointer: coarse)').matches);
        
        if (isMobile) {
            // Virtual joystick state
            const joystick = {
                active: false,
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                deltaX: 0,
                deltaY: 0
            };
            
            const joystickZone = document.getElementById('joystickZone');
            const joystickStick = document.getElementById('joystickStick');
            const maxDistance = 45; // Maximum joystick distance from center
            
            // Touch handlers for joystick
            joystickZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystickZone.getBoundingClientRect();
                joystick.active = true;
                joystick.startX = rect.left + rect.width / 2;
                joystick.startY = rect.top + rect.height / 2;
                updateJoystick(touch.clientX, touch.clientY);
            }, { passive: false });
            
            joystickZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (joystick.active) {
                    const touch = e.touches[0];
                    updateJoystick(touch.clientX, touch.clientY);
                }
            }, { passive: false });
            
            joystickZone.addEventListener('touchend', (e) => {
                e.preventDefault();
                joystick.active = false;
                joystick.deltaX = 0;
                joystick.deltaY = 0;
                joystickStick.style.left = '50%';
                joystickStick.style.top = '50%';
                moveState.forward = false;
                moveState.backward = false;
                moveState.left = false;
                moveState.right = false;
            }, { passive: false });
            
            function updateJoystick(touchX, touchY) {
                const deltaX = touchX - joystick.startX;
                const deltaY = touchY - joystick.startY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                if (distance > maxDistance) {
                    const angle = Math.atan2(deltaY, deltaX);
                    joystick.currentX = Math.cos(angle) * maxDistance;
                    joystick.currentY = Math.sin(angle) * maxDistance;
                } else {
                    joystick.currentX = deltaX;
                    joystick.currentY = deltaY;
                }
                
                // Update visual position
                joystickStick.style.left = `calc(50% + ${joystick.currentX}px)`;
                joystickStick.style.top = `calc(50% + ${joystick.currentY}px)`;
                
                // Calculate normalized values (-1 to 1)
                joystick.deltaX = joystick.currentX / maxDistance;
                joystick.deltaY = joystick.currentY / maxDistance;
                
                // Update movement state based on joystick position
                const threshold = 0.3;
                moveState.forward = joystick.deltaY < -threshold;
                moveState.backward = joystick.deltaY > threshold;
                moveState.left = joystick.deltaX < -threshold;
                moveState.right = joystick.deltaX > threshold;
            }
            
            // Action buttons
            document.getElementById('jumpButton').addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (moveState.canJump) {
                    moveState.jump = true;
                }
            }, { passive: false });
            
            document.getElementById('gatherButton').addEventListener('touchstart', (e) => {
                e.preventDefault();
                gatherResource();
            }, { passive: false });
            
            // Tap to interact/attack (screen tap outside controls)
            let tapTimeout;
            canvas.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                
                // Check if touch is not on controls (right side for attack)
                if (touchX > rect.width / 2 && touchY < rect.height - 200) {
                    tapTimeout = setTimeout(() => {
                        if (controls.isLocked) {
                            attack();
                        } else {
                            controls.lock();
                        }
                    }, 50);
                }
            });
            
            canvas.addEventListener('touchend', () => {
                clearTimeout(tapTimeout);
            });
            
            // Camera control via touch drag on right side of screen
            let lastTouchX = 0;
            let lastTouchY = 0;
            let isCameraDragging = false;
            
            canvas.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                
                // Right half of screen for camera control
                if (touchX > rect.width / 2) {
                    isCameraDragging = true;
                    lastTouchX = touch.clientX;
                    lastTouchY = touch.clientY;
                    
                    // Auto-lock controls for mobile
                    if (!controls.isLocked) {
                        controls.lock();
                    }
                }
            }, { passive: true });
            
            canvas.addEventListener('touchmove', (e) => {
                if (isCameraDragging && controls.isLocked) {
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - lastTouchX;
                    const deltaY = touch.clientY - lastTouchY;
                    
                    // Sensitivity adjustment for mobile
                    const sensitivity = 0.003;
                    
                    // Get the Euler angles
                    const euler = new THREE.Euler(0, 0, 0, 'YXZ');
                    euler.setFromQuaternion(camera.quaternion);
                    
                    // Update rotation
                    euler.y -= deltaX * sensitivity;
                    euler.x -= deltaY * sensitivity;
                    euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
                    
                    camera.quaternion.setFromEuler(euler);
                    
                    lastTouchX = touch.clientX;
                    lastTouchY = touch.clientY;
                }
            }, { passive: true });
            
            canvas.addEventListener('touchend', () => {
                isCameraDragging = false;
            }, { passive: true });
        }
        
        // Game actions
        function gatherResource() {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            const intersects = raycaster.intersectObjects(gameState.resources);
            
            if (intersects.length > 0 && intersects[0].distance < 5) {
                const resource = intersects[0].object;
                const resourceType = resource.userData.resourceType;
                
                // Create particle effect
                createParticleEffect(resource.position, resource.material.color);
                
                // Add to inventory
                gameState.inventory.push(resourceType);
                gameState.xp += 5;
                
                // Remove from scene
                scene.remove(resource);
                gameState.resources = gameState.resources.filter(r => r !== resource);
                
                showMessage(`Gathered ${resourceType}! +5 XP`);
                updateHUD();
            }
        }
        
        function attack() {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            const intersects = raycaster.intersectObjects(gameState.enemies, true);
            
            if (intersects.length > 0 && intersects[0].distance < 10) {
                const enemy = intersects[0].object.parent.type === 'Group' ? 
                             intersects[0].object.parent : intersects[0].object;
                const damage = 10 + Math.floor(Math.random() * 10);
                enemy.userData.health -= damage;
                
                // Create hit particle effect
                createParticleEffect(enemy.position, 0xff0000);
                
                // Visual feedback - flash the enemy
                enemy.children.forEach(child => {
                    if (child.material) {
                        const originalEmissive = child.material.emissive.getHex();
                        child.material.emissive.setHex(0xff0000);
                        setTimeout(() => child.material.emissive.setHex(originalEmissive), 100);
                    }
                });
                
                if (enemy.userData.health <= 0) {
                    // Death particle effect
                    createParticleEffect(enemy.position, 0xffff00);
                    
                    scene.remove(enemy);
                    gameState.enemies = gameState.enemies.filter(e => e !== enemy);
                    gameState.xp += 10;
                    
                    // Drop loot
                    const loot = ['Iron', 'Copper', 'Bone', 'Leather'][Math.floor(Math.random() * 4)];
                    gameState.inventory.push(loot);
                    
                    showMessage(`Defeated ${enemy.userData.name}! Looted ${loot}. +10 XP`);
                    updateHUD();
                }
            }
        }
        
        function craft() {
            if (gameState.inventory.length < 2) {
                showMessage('Need at least 2 items to craft!');
                return;
            }
            
            const items = gameState.inventory.splice(0, 2);
            const craftedItem = `${items[0]}-${items[1]} Artifact`;
            gameState.inventory.push(craftedItem);
            gameState.xp += 30;
            
            showMessage(`Crafted: ${craftedItem}! +30 XP`);
            updateHUD();
        }
        
        function selectSlot(slot) {
            gameState.activeSlot = slot;
            document.querySelectorAll('.inventory-slot').forEach((el, i) => {
                el.classList.toggle('active', i === slot);
            });
        }
        
        function showMessage(text) {
            document.getElementById('messageText').textContent = text;
            document.getElementById('message').classList.add('show');
            setTimeout(() => {
                document.getElementById('message').classList.remove('show');
            }, 3000);
        }
        
        function closeMessage() {
            document.getElementById('message').classList.remove('show');
        }
        
        function updateHUD() {
            document.getElementById('health').textContent = gameState.health;
            document.getElementById('xp').textContent = gameState.xp;
            document.getElementById('position').textContent = 
                `${Math.floor(camera.position.x)}, ${Math.floor(camera.position.y)}, ${Math.floor(camera.position.z)}`;
            
            // Update inventory display
            document.querySelectorAll('.inventory-slot').forEach((slot, i) => {
                const item = gameState.inventory[i];
                if (item) {
                    slot.innerHTML = `<span>${item.substring(0, 8)}</span>`;
                } else {
                    slot.innerHTML = '<span>Empty</span>';
                }
            });
            
            // Update biome
            const raycaster = new THREE.Raycaster(camera.position, new THREE.Vector3(0, -1, 0));
            const intersects = raycaster.intersectObjects(scene.children);
            if (intersects.length > 0 && intersects[0].object.userData.biome) {
                document.getElementById('biome').textContent = intersects[0].object.userData.biome;
            }
        }
        
        // Animation loop
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            // Update particles
            updateParticles(delta);
            
            // Animate resources (bobbing)
            gameState.resources.forEach(resource => {
                if (resource.userData.bobPhase !== undefined) {
                    resource.position.y = resource.userData.originalY || resource.position.y;
                    if (!resource.userData.originalY) {
                        resource.userData.originalY = resource.position.y;
                    }
                    resource.position.y += Math.sin(time * 2 + resource.userData.bobPhase) * 0.1;
                    resource.rotation.y += delta * 0.5;
                }
            });
            
            // Animate enemies (slight sway)
            gameState.enemies.forEach(enemy => {
                enemy.rotation.y += Math.sin(time * 3) * 0.01;
            });
            
            if (controls.isLocked) {
                // Physics
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 3 * delta; // Gravity
                
                direction.z = Number(moveState.forward) - Number(moveState.backward);
                direction.x = Number(moveState.right) - Number(moveState.left);
                direction.normalize();
                
                const speed = moveState.sprint ? 30 : 15;
                
                if (moveState.forward || moveState.backward) velocity.z -= direction.z * speed * delta;
                if (moveState.left || moveState.right) velocity.x -= direction.x * speed * delta;
                
                if (moveState.jump) {
                    velocity.y = 10;
                    moveState.jump = false;
                    moveState.canJump = false;
                }
                
                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                
                camera.position.y += velocity.y * delta;
                
                // Ground collision
                if (camera.position.y < 1.6) {
                    camera.position.y = 1.6;
                    velocity.y = 0;
                    moveState.canJump = true;
                }
                
                // Enemy AI - simple follow player
                gameState.enemies.forEach(enemy => {
                    const direction = new THREE.Vector3();
                    direction.subVectors(camera.position, enemy.position).normalize();
                    enemy.position.x += direction.x * delta * 2;
                    enemy.position.z += direction.z * delta * 2;
                    
                    // Attack player if close
                    const distance = enemy.position.distanceTo(camera.position);
                    if (distance < 2 && Math.random() > 0.98) {
                        gameState.health -= 5;
                        if (gameState.health <= 0) {
                            showMessage('You died! Game Over.');
                            gameState.health = 100;
                            camera.position.set(0, 1.6, 0);
                        }
                        updateHUD();
                    }
                });
                
                updateHUD();
            }
            
            renderer.render(scene, camera);
        }
        
        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize
        generateWorld();
        document.getElementById('loading').classList.add('hidden');
        animate();
        
        // Show instructions
        setTimeout(() => {
            showMessage('Welcome to Realm of Echoes 3D! Click to start. Use WASD to move, mouse to look, E to gather, Left Click to attack!');
        }, 500);
    </script>
</body>
</html>
